import argparse
import mariadb
import os
import textwrap
import sys
import time

pj = os.path.join


class GPeasantSphinx(object):
    """Pull data from gpeasant database and generate corresponding
    reStructuredText files into a Sphinx source path using templates.
    """

    def __init__(
            self, db_user, db_user_passwd, db_host, db_port, db_database):
        super(GPeasantSphinx, self).__init__()

        # Connect to MariaDB Platform
        try:
            conn = mariadb.connect(
                user=db_user,
                password=db_user_passwd,
                host=db_host,
                port=db_port,
                database=db_database
            )

        except mariadb.Error as e:
            print(f"Error connecting to MariaDB Platform: {e}")
            sys.exit(1)

        self.cur = conn.cursor()

        self.root_dir = os.path.join(
            os.path.abspath(os.getcwd()), 'gp')

        self.root_title = 'Административно-территориальное деление'
        self.root_filename = 'gp.rst'
        self.index_filename = 'index.rst'

        # gp/gubernia/index.rst
        # gp/gubernia/<:id>/uezd/index.rst
        # gp/gubernia/<:id>/uezd/<:id>/locality/index.rst
        # gp/gubernia/<:id>/uezd/<:id>/locality/<:id>/church/index.rst
        self.tree_templ = textwrap.dedent("""
        .. Tree RST template
        .. Autogenerated by gp-sphinx.py

        {_title_}

        .. toctree::
           :maxdepth: {_maxdepth_}

        {_members_}

        """)

        # gp/gubernia/<:id>/uezd/<:id>/locality/<:id>/church/<:id>/index.rst
        self.datasheet_templ = textwrap.dedent("""
        .. Church datasheet RST template
        .. Autogenerated by gp-sphinx.py

        .. index:: {_index_}

        {_title_}

        .. list-table::
           :header-rows: 1
           :widths: 10 70 20

           * - #
             - Категория крестьян
             - Количество душ м.п.

        {_datasheet_}

        """)

        self.__current_gub = ''

    def make_dirs(self, path):
        """ Creates directories using path"""
        path = os.path.join(self.root_dir, path)
        try:
            if(os.path.exists(path)):
                os.rmdir(path)
            os.makedirs(path)
        except OSError as e:
            print(f"Could not create directory: {e}")
            sys.exit(1)

    def file_write(self, fn, rst):
        """Writes RST content to file, creates one if not exists"""
        file = open(os.path.join(self.root_dir, fn), 'w+')
        file.write(rst)
        file.close()

    def format3(self, name):
        """Prepend 3 wite spaces."""
        return '   %s' % name

    def format_header(self, name):
        """Underline heder name"""
        return '%s\n' % name + ('=' * len(name))

    def format_table_row(self, cols, counter):
        _row = self.format3('* - ' + str(counter) + '\n')

        for col in cols:
            if col is not None:
                # escape newlines
                col = str(col).replace('\n', '\n\n       ')
            else:
                col = ''

            _row += self.format3('  - ' + col + '\n')

        return _row

    def __gen_gubernias(self, root_dir):
        self.cur.execute("SELECT id, name FROM gubernia ORDER BY name")
        gubernias = self.cur.fetchall()

        _g_list = ''

        for (g_id, g_name) in gubernias:
            self.__current_gub = g_name
            print("%s\tprocesing..." % self.__current_gub, end=' ', flush=True)

            _g_list += self.format3(f'gubernia/{g_id}/index\n')

            child_dir = pj(root_dir, 'gubernia', str(g_id))
            self.make_dirs(child_dir)

            self.__gen_uezds(g_id, g_name, child_dir)

            print("\r%s\tDone!       " %
                  self.__current_gub, end='\n', flush=True)

        rst = self.tree_templ.format(
            _title_=self.format_header(self.root_title),
            _members_=_g_list,
            _maxdepth_=2)

        self.file_write(pj(self.root_dir, self.root_filename), rst)

    def __gen_uezds(self, g_id, g_name, pdir):
        self.cur.execute(
            "SELECT id, name FROM uezd WHERE gub_id=? ORDER BY name", (g_id,))
        uezds = self.cur.fetchall()

        _u_list = ''

        for (u_id, u_name) in uezds:
            _u_list += self.format3(f'uezd/{u_id}/index\n')

            child_dir = pj(pdir, 'uezd', str(u_id))
            self.make_dirs(child_dir)

            self.__gen_volosts(u_id, u_name, child_dir)

        rst = self.tree_templ.format(
            _title_=self.format_header(g_name),
            _members_=_u_list,
            _maxdepth_=2)

        self.file_write(pj(pdir, self.index_filename), rst)

    def __gen_volosts(self, u_id, u_name, pdir):
        self.cur.execute(
            "SELECT id, name FROM volost WHERE uezd_id=? ORDER BY name", (u_id,))
        localities = self.cur.fetchall()

        _v_list = ''

        for (v_id, v_name) in localities:
            _v_list += self.format3(f'volost/{v_id}/index\n')

            child_dir = pj(pdir, 'volost', str(v_id))
            self.make_dirs(child_dir)

            self.__gen_localities(v_id, v_name, child_dir)

        rst = self.tree_templ.format(
            _title_=self.format_header(u_name),
            _members_=_v_list,
            _maxdepth_=1)

        self.file_write(pj(pdir, self.index_filename), rst)

    def __gen_localities(self, v_id, v_name, pdir):
        self.cur.execute(
            "SELECT id, name FROM locality WHERE volost_id=? ORDER BY name", (v_id,))
        localities = self.cur.fetchall()

        _l_list = ''

        for (l_id, l_name) in localities:
            _l_list += self.format3(f'locality/{l_id}/index\n')

            child_dir = pj(pdir, 'locality', str(l_id))
            self.make_dirs(child_dir)

            self.__gen_datasheets(l_id, l_name, child_dir)

        rst = self.tree_templ.format(
            _title_=self.format_header(v_name),
            _members_=_l_list,
            _maxdepth_=1)

        self.file_write(pj(pdir, self.index_filename), rst)

    def __gen_datasheets(self, l_id, l_name, pdir):
        self.cur.execute(
            "SELECT category.name AS category, count.count AS count \
            FROM count \
            LEFT JOIN category ON count.category_id=category.id \
            WHERE count.locality_id=? ORDER BY category.name", (l_id,))

        catcount = self.cur.fetchall()

        table = ''
        counter = 1

        for (category, count) in catcount:
            table += self.format_table_row((category, count), counter)
            counter += 1

        rst = self.datasheet_templ.format(
            _index_=' '.join(l_name.split()[1:]),
            _title_=self.format_header(l_name),
            _datasheet_=table)

        self.file_write(pj(pdir, self.index_filename), rst)

    # def __gen_churches(self, l_id, l_name, pdir):
    #    self.cur.execute(
    #        "SELECT id, name FROM cfp_church WHERE locality_id=?", (l_id,))
    #    churches = self.cur.fetchall()

    #    _ch_list = ''

    #    for (ch_id, ch_name) in churches:
    #        _ch_list += self.format3(f'church/{ch_id}/index\n')

    #        child_dir = pj(pdir, 'church', str(ch_id))
    #        self.make_dirs(child_dir)

    #        self.__gen_datasheets(ch_id, ch_name, child_dir)

    #    rst = self.tree_templ.format(
    #        _title_=self.format_header(l_name),
    #        _members_=_ch_list,
    #        _maxdepth_=1)

    #    self.file_write(pj(pdir, self.index_filename), rst)

    # def __gen_datasheets(self, ch_id, ch_name, pdir):
    #    self.cur.execute(
    #        "SELECT cfp_doctype.name AS dtname, \
     #       ( \
    #            SELECT \
    #            GROUP_CONCAT(cfp_docyears.year \
    #                            ORDER BY cfp_docyears.year SEPARATOR ',') \
    #            FROM cfp_docyears \
    #            WHERE cfp_docyears.doc_id=cfp_doc.id \
    #        ) AS years, \
    #       CONCAT( \
    #               'Ф.', cfp_fund.name, \
    #               ' Оп.', cfp_doc.inventory, \
    #                ' Д.', cfp_doc.unit \
    #        ) AS unit, \
    #        cfp_doc.sheets, \
    #        ( \
    #            SELECT \
    #            GROUP_CONCAT(cfp_docflag.name \
    #                            ORDER BY cfp_docflag.name SEPARATOR ',') \
    #            FROM cfp_docflags LEFT JOIN cfp_docflag \
    #            ON cfp_docflags.docflag_id=cfp_docflag.id \
    #            WHERE cfp_docflags.doc_id=cfp_doc.id \
    #        ) AS flags, \
    #        cfp_doc.comment AS comment \
    #        FROM cfp_doc \
    #        LEFT JOIN cfp_doctype ON cfp_doc.doctype_id=cfp_doctype.id \
    #        LEFT JOIN cfp_fund ON cfp_doc.fund_id=cfp_fund.id \
    #        WHERE cfp_doc.church_id=?", (ch_id,))
    #    data = self.cur.fetchall()

    #    table = ''
    #    counter = 1

    #    for (dtname, years, unit, sheets, flags, comment) in data:
    #        years = self.make_years_range(years)
    #        flags = self.make_abbr(flags)

    #        table += self.format_table_row(
    #           (dtname, years, unit, sheets, flags, comment), counter)
    #        counter += 1

    #    rst = self.datasheet_templ.format(
    #        _index_=ch_name,
    #        _title_=self.format_header(ch_name),
    #        _datasheet_=table)

    #    self.file_write(pj(pdir, self.index_filename), rst)

    def generate(self):
        self.__gen_gubernias(self.root_dir)


def main():
    parser = argparse.ArgumentParser(
        description='GPeasantSphinx RST autogen 2020 Sakharuk Alexander')

    parser.add_argument('--db', default='gpeasant',
                        action='store', help='Database name')
    parser.add_argument('--host', default='localhost',
                        action='store', help='Database hostname')
    parser.add_argument('--port', default=3306,
                        action='store', help='Database port')
    parser.add_argument('--password', default='',
                        action='store', help='Database password')
    parser.add_argument('--user', default='root',
                        action='store', help='Database username')

    args = parser.parse_args()

    gp = GPeasantSphinx(args.user, args.password,
                        args.host, args.port, args.db)
    gp.generate()


if __name__ == '__main__':
    main()
